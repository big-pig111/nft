<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Solana NFT é“¸é€ </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  
  <!-- Buffer Polyfill for browser -->
  <script src="https://bundle.run/buffer@6.0.3"></script>
  <script>
    window.Buffer = buffer.Buffer;
  </script>
  
  <!-- Solana Web3.js -->
  <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>
  
  <script>
    console.log("Solana Web3.js åŠ è½½æˆåŠŸ");
    console.log("Buffer å¯ç”¨:", typeof window.Buffer !== 'undefined');
  </script>
</head>
<body class="bg-gray-100">
  <div class="max-w-xl mx-auto mt-10 p-6 bg-white shadow-lg rounded-xl">
    <h1 class="text-2xl font-bold mb-4">Solana NFT é“¸é€ </h1>
    <p class="text-sm text-gray-600 mb-4">å°†æ‚¨çš„ç…§ç‰‡å’Œæ–‡å­—é“­åˆ»åœ¨ Solana ä¸»ç½‘ä¸Šï¼Œåˆ›å»ºçœŸæ­£çš„ NFT</p>
    <button id="connectWallet" class="bg-blue-600 text-white px-4 py-2 rounded mb-4">è¿æ¥é’±åŒ…</button>
    <button id="checkLibraries" class="bg-green-600 text-white px-4 py-2 rounded mb-4 ml-2">æ£€æŸ¥åº“çŠ¶æ€</button>
    <input id="nftName" type="text" placeholder="è¾“å…¥ NFT åç§°" class="border p-2 w-full mb-2" />
    <textarea id="nftDesc" placeholder="è¾“å…¥ NFT æè¿°" class="border p-2 w-full mb-2"></textarea>
    <input id="imageUpload" type="file" accept="image/*" class="mb-4" />
    <button id="mintButton" class="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700">é“¸é€  NFT</button>
    <p class="text-xs text-gray-500 mt-2">æ³¨æ„ï¼šé“¸é€  NFT éœ€è¦æ”¯ä»˜ Solana ç½‘ç»œè´¹ç”¨ï¼ˆçº¦ 0.01-0.05 SOLï¼‰</p>
    <p id="status" class="mt-4 text-sm text-gray-600 whitespace-pre-wrap"></p>
  </div>

  <script>
    const TOKEN_METADATA_PROGRAM_ID = new solanaWeb3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
    let provider = null;

    document.getElementById("connectWallet").onclick = async () => {
      if ("solana" in window) {
        provider = window.solana;
        await provider.connect();
        document.getElementById("connectWallet").innerText = "âœ… å·²è¿æ¥é’±åŒ…";
      } else {
        alert("è¯·å®‰è£… Phantom é’±åŒ…");
      }
    };

    document.getElementById("checkLibraries").onclick = () => {
      const status = document.getElementById("status");
      const libraries = {
        "Solana Web3.js": typeof solanaWeb3 !== 'undefined',
        "Buffer": typeof window.Buffer !== 'undefined'
      };
      
      let statusText = "ğŸ“Š åº“çŠ¶æ€æ£€æŸ¥ï¼š\n\n";
      Object.entries(libraries).forEach(([name, loaded]) => {
        statusText += `${loaded ? 'âœ…' : 'âŒ'} ${name}: ${loaded ? 'å·²åŠ è½½' : 'æœªåŠ è½½'}\n`;
      });
      
      statusText += "\nğŸ’¡ ä½¿ç”¨åŸºç¡€ Solana æ–¹æ³•åˆ›å»º NFT";
      
      status.textContent = statusText;
    };

    // åˆ›å»º Solana NFT ä»£å¸
    async function createSolanaNFT(connection, provider, name, desc, file, status) {
      try {
        status.textContent = "ğŸ”„ æ­£åœ¨åˆ›å»º Solana ä»£å¸...";
        
        // æ£€æŸ¥å¿…è¦çš„å¯¹è±¡
        if (!provider || !provider.publicKey) {
          throw new Error("é’±åŒ…æœªè¿æ¥");
        }
        
        console.log("é’±åŒ…åœ°å€:", provider.publicKey.toString());
        
        // ç”Ÿæˆæ–°çš„å¯†é’¥å¯¹ä½œä¸º mint è´¦æˆ·
        const mintKeypair = solanaWeb3.Keypair.generate();
        console.log("Mint åœ°å€:", mintKeypair.publicKey.toString());
        
        // ç¬¬ä¸€æ­¥ï¼šåˆ›å»º mint è´¦æˆ·
        status.textContent = "ğŸ“ æ­¥éª¤ 1/3: åˆ›å»º Mint è´¦æˆ·...";
        const lamports = await connection.getMinimumBalanceForRentExemption(82);
        
        const createAccountTx = new solanaWeb3.Transaction();
        createAccountTx.add(
          solanaWeb3.SystemProgram.createAccount({
            fromPubkey: provider.publicKey,
            newAccountPubkey: mintKeypair.publicKey,
            lamports: lamports,
            space: 82,
            programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
          })
        );
        
        createAccountTx.feePayer = provider.publicKey;
        const { blockhash: blockhash1 } = await connection.getLatestBlockhash();
        createAccountTx.recentBlockhash = blockhash1;
        
        createAccountTx.sign(mintKeypair);
        const signedCreateTx = await provider.signTransaction(createAccountTx);
        const createTxid = await connection.sendRawTransaction(signedCreateTx.serialize());
        await connection.confirmTransaction(createTxid);
        
        console.log("Mint è´¦æˆ·åˆ›å»ºæˆåŠŸ:", createTxid);
        
        // ç¬¬äºŒæ­¥ï¼šåˆå§‹åŒ– mint
        status.textContent = "ğŸ”§ æ­¥éª¤ 2/3: åˆå§‹åŒ– Mint...";
        const initTx = new solanaWeb3.Transaction();
        
        // ä½¿ç”¨æ­£ç¡®çš„åˆå§‹åŒ–æŒ‡ä»¤
        const initData = Buffer.alloc(82);
        initData.writeUInt8(0, 0); // InitializeMint
        initData.writeUInt8(0, 1); // decimals = 0
        
        // å†™å…¥ mint authority
        provider.publicKey.toBuffer().copy(initData, 2);
        
        // å†™å…¥ freeze authority (null)
        new solanaWeb3.PublicKey("11111111111111111111111111111111").toBuffer().copy(initData, 34);
        
        initTx.add(
          new solanaWeb3.TransactionInstruction({
            keys: [
              { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: true },
              { pubkey: new solanaWeb3.PublicKey("11111111111111111111111111111111"), isSigner: false, isWritable: false },
            ],
            programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
            data: initData,
          })
        );
        
        initTx.feePayer = provider.publicKey;
        const { blockhash: blockhash2 } = await connection.getLatestBlockhash();
        initTx.recentBlockhash = blockhash2;
        
        const signedInitTx = await provider.signTransaction(initTx);
        const initTxid = await connection.sendRawTransaction(signedInitTx.serialize());
        await connection.confirmTransaction(initTxid);
        
        console.log("Mint åˆå§‹åŒ–æˆåŠŸ:", initTxid);
        
        // ç¬¬ä¸‰æ­¥ï¼šåˆ›å»ºä»£å¸è´¦æˆ·å¹¶é“¸é€ 
        status.textContent = "ğŸª™ æ­¥éª¤ 3/3: åˆ›å»ºä»£å¸è´¦æˆ·å¹¶é“¸é€ ...";
        
        // åˆ›å»ºç®€å•çš„ä»£å¸è´¦æˆ·ï¼ˆä¸ä½¿ç”¨å…³è”ä»£å¸è´¦æˆ·ï¼‰
        const tokenAccount = solanaWeb3.Keypair.generate();
        const tokenAccountLamports = await connection.getMinimumBalanceForRentExemption(165);
        
        const mintTx = new solanaWeb3.Transaction();
        
        // åˆ›å»ºä»£å¸è´¦æˆ·
        mintTx.add(
          solanaWeb3.SystemProgram.createAccount({
            fromPubkey: provider.publicKey,
            newAccountPubkey: tokenAccount.publicKey,
            lamports: tokenAccountLamports,
            space: 165,
            programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
          })
        );
        
        // åˆå§‹åŒ–ä»£å¸è´¦æˆ·
        const initAccountData = Buffer.alloc(165);
        initAccountData.writeUInt8(1, 0); // InitializeAccount
        mintKeypair.publicKey.toBuffer().copy(initAccountData, 1);
        provider.publicKey.toBuffer().copy(initAccountData, 33);
        
        mintTx.add(
          new solanaWeb3.TransactionInstruction({
            keys: [
              { pubkey: tokenAccount.publicKey, isSigner: false, isWritable: true },
              { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
              { pubkey: provider.publicKey, isSigner: false, isWritable: false },
              { pubkey: new solanaWeb3.PublicKey("11111111111111111111111111111111"), isSigner: false, isWritable: false },
            ],
            programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
            data: initAccountData,
          })
        );
        
        // é“¸é€ ä»£å¸
        const mintToData = Buffer.alloc(9);
        mintToData.writeUInt8(7, 0); // MintTo
        mintToData.writeBigUInt64LE(BigInt(1), 1);
        
        mintTx.add(
          new solanaWeb3.TransactionInstruction({
            keys: [
              { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: true },
              { pubkey: tokenAccount.publicKey, isSigner: false, isWritable: true },
              { pubkey: provider.publicKey, isSigner: true, isWritable: false },
            ],
            programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
            data: mintToData,
          })
        );
        
        mintTx.feePayer = provider.publicKey;
        const { blockhash: blockhash3 } = await connection.getLatestBlockhash();
        mintTx.recentBlockhash = blockhash3;
        
        mintTx.sign(tokenAccount);
        const signedMintTx = await provider.signTransaction(mintTx);
        const mintTxid = await connection.sendRawTransaction(signedMintTx.serialize());
        await connection.confirmTransaction(mintTxid);
        
        console.log("ä»£å¸é“¸é€ æˆåŠŸ:", mintTxid);
        
        // åˆ›å»ºå…ƒæ•°æ®
        const metadata = {
          name: name,
          description: desc,
          image: await fileToBase64(file),
          attributes: [
            { trait_type: "Creator", value: "Solana NFT Tool" },
            { trait_type: "Created", value: new Date().toISOString() }
          ]
        };
        
        status.textContent = `âœ… NFT åˆ›å»ºæˆåŠŸï¼\n\nğŸ¨ NFT åç§°ï¼š${name}\nğŸ“ æè¿°ï¼š${desc}\nğŸ”— Mint åœ°å€ï¼š${mintKeypair.publicKey.toString()}\nğŸ’° ä»£å¸è´¦æˆ·ï¼š${tokenAccount.publicKey.toString()}\nğŸ“Š åˆ›å»ºäº¤æ˜“ï¼š${createTxid}\nğŸ“Š åˆå§‹åŒ–äº¤æ˜“ï¼š${initTxid}\nğŸ“Š é“¸é€ äº¤æ˜“ï¼š${mintTxid}\n\nğŸŒ æŸ¥çœ‹ Mintï¼šhttps://explorer.solana.com/address/${mintKeypair.publicKey.toString()}\nğŸ’¾ å…ƒæ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°`;
      } catch (err) {
        console.error(err);
        status.textContent = "âŒ å‡ºé”™äº†: " + err.message;
      }
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šæ–‡ä»¶è½¬ Base64
    async function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
      });
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šè·å–å…³è”ä»£å¸åœ°å€
    async function getAssociatedTokenAddress(mint, owner) {
      const [address] = await solanaWeb3.PublicKey.findProgramAddress(
        [
          owner.toBuffer(),
          new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA").toBuffer(),
          mint.toBuffer(),
        ],
        new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
      );
      return address;
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºå…³è”ä»£å¸è´¦æˆ·æŒ‡ä»¤
    function createAssociatedTokenAccountInstruction(
      payer,
      associatedToken,
      owner,
      mint
    ) {
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: associatedToken, isSigner: false, isWritable: true },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: new solanaWeb3.PublicKey("11111111111111111111111111111111"), isSigner: false, isWritable: false },
        { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
        { pubkey: new solanaWeb3.PublicKey("SysvarRent111111111111111111111111111111111"), isSigner: false, isWritable: false },
      ];
      
      return new solanaWeb3.TransactionInstruction({
        keys,
        programId: new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
        data: Buffer.alloc(0),
      });
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºé“¸é€ æŒ‡ä»¤
    function createMintToInstruction(mint, destination, authority, amount) {
      const keys = [
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true },
        { pubkey: authority, isSigner: true, isWritable: false },
      ];
      
      const data = Buffer.alloc(9);
      data.writeUInt8(7, 0); // MintTo instruction
      data.writeBigUInt64LE(BigInt(amount), 1);
      
      return new solanaWeb3.TransactionInstruction({
        keys,
        programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
        data,
      });
    }

    document.getElementById("mintButton").onclick = async () => {
      const status = document.getElementById("status");
      const name = document.getElementById("nftName").value;
      const desc = document.getElementById("nftDesc").value;
      const file = document.getElementById("imageUpload").files[0];

      if (!provider || !provider.publicKey) {
        status.textContent = "âŒ è¯·å…ˆè¿æ¥é’±åŒ…";
        return;
      }
      if (!name || !desc || !file) {
        status.textContent = "âŒ è¯·å¡«å†™å®Œæ•´çš„ NFT ä¿¡æ¯ï¼ˆåç§°ã€æè¿°ã€å›¾ç‰‡ï¼‰";
        return;
      }

      // æ£€æŸ¥ Buffer æ˜¯å¦å¯ç”¨
      if (typeof window.Buffer === 'undefined') {
        status.textContent = "âŒ Buffer æœªå®šä¹‰ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•";
        return;
      }

      status.textContent = "ğŸ“¦ æ­£åœ¨åˆ›å»º NFT...";
      try {
        const connection = new solanaWeb3.Connection(
          "https://small-holy-forest.solana-mainnet.quiknode.pro/b59315ea187b3de1b3542c5c25d7f2d5b5410ff4/",
          "confirmed"
        );

        // å…ˆæµ‹è¯•ç®€å•çš„äº¤æ˜“
        await testSimpleTransaction(connection, provider, status);
        
        // å¦‚æœç®€å•äº¤æ˜“æˆåŠŸï¼Œå†åˆ›å»º NFT
        await createSolanaNFT(connection, provider, name, desc, file, status);
      } catch (err) {
        console.error(err);
        status.textContent = "âŒ å‡ºé”™äº†: " + err.message;
      }
    };
    
    // æµ‹è¯•ç®€å•äº¤æ˜“
    async function testSimpleTransaction(connection, provider, status) {
      status.textContent = "ğŸ§ª æ­£åœ¨æµ‹è¯•ç½‘ç»œè¿æ¥...";
      
      // åˆ›å»ºä¸€ä¸ªç®€å•çš„è½¬è´¦äº¤æ˜“
      const transaction = new solanaWeb3.Transaction();
      transaction.add(
        solanaWeb3.SystemProgram.transfer({
          fromPubkey: provider.publicKey,
          toPubkey: provider.publicKey, // è½¬ç»™è‡ªå·±
          lamports: 1000, // å¾ˆå°çš„é‡‘é¢
        })
      );
      
      transaction.feePayer = provider.publicKey;
      const { blockhash } = await connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      
      const signedTx = await provider.signTransaction(transaction);
      const txid = await connection.sendRawTransaction(signedTx.serialize());
      await connection.confirmTransaction(txid);
      
      status.textContent = "âœ… ç½‘ç»œè¿æ¥æ­£å¸¸ï¼Œå¼€å§‹åˆ›å»º NFT...";
    }
  </script>
</body>
</html>
